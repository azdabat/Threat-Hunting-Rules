let lookback = 60m;
let confidence_threshold = 3;
let suspicious_folders = dynamic(["C:\\Users\\Public\\", "C:\\ProgramData\\", "C:\\Temp\\", "C:\\Users\\", "C:\\Windows\\Tasks\\"]);
let writable_driver_locations = dynamic(["C:\\ProgramData\\", "C:\\Users\\", "C:\\Temp\\", "C:\\Windows\\Tasks\\"]);
let registry_keywords = dynamic([".dll", ".exe", ".ps1", ".bat", ".vbs", ".cmd", ".js", "rundll32.exe", "mshta.exe", "powershell.exe", "cmd.exe"]);
let known_malicious_hashes = dynamic(["f1e2d3c4b5a6..."]); // Replace with known-bad hashes

// DLL Load Events
let dll_loads = DeviceImageLoadEvents
| where Timestamp >= ago(lookback)
| where ImageFileName endswith ".dll"
| where (Signed == "False" or isnull(Signer) or SignatureStatus has_any ("Unsigned", "Unknown", "Invalid"))
| extend FolderPath = tostring(split(ImageFileName, "\\", -2)[0])
| project LoadTime = Timestamp, DeviceName, ProcessId, ProcessName, ImageFileName, ImageHash, FolderPath;

// File Creations
let file_drops = DeviceFileEvents
| where Timestamp >= ago(lookback)
| where FolderPath startswith_any (suspicious_folders)
| where FileName endswith ".dll" or FileName endswith ".sys"
| project DropTime = Timestamp, DeviceName, FileName, FileHash, FolderPath, InitiatingProcessFileName, InitiatingProcessCommandLine;

// Downloads
let net_downloads = DeviceNetworkEvents
| where Timestamp >= ago(lookback)
| where RemoteUrl has_any (".dll", ".sys", ".bin", ".exe")
| project DownloadTime = Timestamp, DeviceName, RemoteUrl, InitiatingProcessFileName;

// Registry Events (all persistence types)
let reg_persistence = DeviceRegistryEvents
| where Timestamp >= ago(lookback)
| where RegistryValueData has_any (registry_keywords)
| project RegTime = Timestamp, DeviceName, RegistryKey, RegistryValueName, RegistryValueData, InitiatingProcessFileName;

// Merge All Signals
dll_loads
| join kind=leftouter (file_drops) on $left.ImageHash == $right.FileHash and $left.DeviceName == $right.DeviceName
| join kind=leftouter (net_downloads) on $left.DeviceName == $right.DeviceName
| join kind=leftouter (reg_persistence) on $left.DeviceName == $right.DeviceName
| extend
    ConfidenceScore =
        iif(ImageHash in (known_malicious_hashes), 5,
        iif(FolderPath startswith_any (writable_driver_locations), 2, 0) +
        iif(isnotempty(RegistryKey), 2, 0) +
        iif(RemoteUrl has ".dll", 1, 0)),
    MITRE_Tactics = "T1574.001, T1547.001, T1036.005, T1055.001, T1543.003",
    ThreatHunterNotes = strcat(
        iif(ImageHash in (known_malicious_hashes), " Known bad hash. ", ""),
        iif(FolderPath startswith_any(writable_driver_locations), " DLL/Driver drop in writable location. ", ""),
        iif(isnotempty(RegistryKey), " Registry persistence via key: ", RegistryKey, ". "),
        iif(isnotempty(RemoteUrl), strcat(" Download from: ", RemoteUrl, ". "), "")
    )
| where ConfidenceScore >= confidence_threshold
| project
    LoadTime, DropTime, DownloadTime, RegTime,
    DeviceName, ProcessName, ImageFileName, ImageHash,
    FileHash, FolderPath, RemoteUrl, RegistryKey, RegistryValueData,
    ConfidenceScore, MITRE_Tactics, ThreatHunterNotes
| order by LoadTime desc
