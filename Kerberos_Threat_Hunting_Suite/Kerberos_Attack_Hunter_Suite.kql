////////////////////////////////////////////////////////////////////////////////////////////
// Kerberos Attack Hunter Suite - Cluster + Component Hunts
// Author: Ala Dabat
// Version: 2025-12
//
// Contents:
//   1) Kerberos_Attack_Cluster_V1              (Master Correlation / Risk Engine)
//   2) L3_Kerberos_Offensive_Tooling_Hunt_V3   (Endpoint - MDE DeviceProcessEvents)
//   3) L3_Kerberoasting_Storm_Hunt_V3          (Identity - Sentinel SecurityEvent 4769)
//   4) L3_Kerberos_Identity_Anomaly_Hunt_V1    (Identity - New host usage per account)
//
// Tables assumed (Sentinel + MDE):
//   - DeviceProcessEvents (Defender for Endpoint)
//   - SecurityEvent (Domain Controller Windows Security logs)
//
// Notes:
//   - All thresholds are tunable. Start with these, then adjust based on noise.
//   - Use this in a hunting notebook first, then promote the pieces you like to
//     scheduled analytics.
//
// MITRE Coverage (suite):
//   - T1558.001 / .003 (Golden Ticket, Kerberoasting)
//   - T1550.003       (Pass-the-Ticket / Overpass-the-Hash)
//   - T1003.001       (LSASS / credential dumping)
//   - T1078           (Valid accounts / account misuse)
//   - T1552 / T1555   (Credential material abuse)
//
// ============================================================================
// 1) Kerberos_Attack_Cluster_V1
//    Master correlation: Endpoint tooling + Kerberoast storm + identity anomaly
// ============================================================================

let lookback               = 24h;
let baselineWindow         = 7d;
let TgsThreshold           = 15;  // Kerberoast SPN diversity threshold per 10 min
let HighRoastThreshold     = 30;
let NewHostMinEvents       = 3;   // Require at least N events from new host before alert
let SuspectTools = dynamic([
    "mimikatz.exe", "rubeus.exe", "kekeo.exe", "impacket.exe", "safetykatz.exe",
    "sharpkatz.exe", "bettersafetykatz.exe", "dumpert.exe"
]);
// Tenant-specific privileged accounts (tune this for your environment)
let PrivilegedAccounts = dynamic([
    "Administrator","krbtgt","svc_backup","svc_sql","svc_ldap",
    "adm_", "_adm", ".admin"  // simple pattern markers, used as substring tests
]);

// -----------------------------------------------------------------------------
// Endpoint Signals: Kerberos offensive tooling (PtT, PtH, Golden, LSASS dump)
// -----------------------------------------------------------------------------
let EndpointSignals =
let PttRegex      = @"(?i)(/ptt\b|ticket::import|/ticket:[a-zA-Z0-9\-_]+\.(kirbi|ccache))";
let ForgingRegex  = @"(?i)(kerberos::golden|kerberos::silver|/sid:S-1-5|/id:500|/groups:512|/rc4:[a-f0-9]{32}|/aes256:[a-f0-9]{64})";
let DumpRegex     = @"(?i)(sekurlsa::tickets|sekurlsa::logonpasswords|/dump(?!bin)|/triage|/export|/monitor)";
let PthRegex      = @"(?i)(sekurlsa::pth|/pth\b|overpass-the-hash|overpass\b|/user:[^ ]+.*\/rc4:|/user:[^ ]+.*\/ntlm:|-hashes\s+:[a-fA-F0-9]{32,})";
DeviceProcessEvents
| where TimeGenerated > ago(lookback)
| where ProcessCommandLine has_any (
    "ticket","kerberos","sekurlsa","ptt","golden","silver",
    "rubeus","kekeo","kirbi","rc4","aes","overpass","sekurlsa::pth",
    "-hashes"
)
| extend
    IsSuspectTool   = FileName in~ (SuspectTools),
    IsForging       = ProcessCommandLine matches regex ForgingRegex,
    IsPtt           = ProcessCommandLine matches regex PttRegex,
    IsDump          = ProcessCommandLine matches regex DumpRegex,
    IsPth           = ProcessCommandLine matches regex PthRegex,
    HasKirbiFile    = ProcessCommandLine has ".kirbi",
    HasCCacheFile   = ProcessCommandLine has ".ccache"
| extend RiskEndpoint =
       iif(IsForging, 100, 0)
     + iif(IsPth,     80,  0)
     + iif(IsPtt,     70,  0)
     + iif(IsDump,    60,  0)
     + iif(IsSuspectTool, 20, 0)
     + iif(HasKirbiFile or HasCCacheFile, 20, 0)
| where RiskEndpoint > 0
| extend Scenario = case(
    IsForging, "Golden/Silver ticket forging",
    IsPth,     "Overpass-the-Hash / PtH",
    IsPtt,     "Pass-the-Ticket injection",
    IsDump,    "Kerberos / ticket dumping",
    "Kerberos tooling"
)
| extend Principal = coalesce(AccountName, InitiatingProcessAccountName, "")
| project
    TimeGenerated,
    DeviceName,
    Principal,
    SourceTable = "DeviceProcessEvents",
    Signal      = "EndpointTooling",
    Scenario,
    RiskScore   = RiskEndpoint,
    Details     = ProcessCommandLine,
    FileName;

// -----------------------------------------------------------------------------
// Identity Signals (1): Kerberoasting storm (SPN diversity per user)
// Uses SecurityEvent 4769 from DCs
// -----------------------------------------------------------------------------
let KerberoastSignals =
SecurityEvent
| where TimeGenerated > ago(lookback)
| where EventID == 4769
| where TicketEncryptionType == "0x17" or isempty(TicketEncryptionType)
| summarize
    DistinctSpnCount = dcount(ServiceName),
    SpnList          = make_set(ServiceName, 100),
    FirstSeen        = min(TimeGenerated),
    LastSeen         = max(TimeGenerated)
  by TargetUserName, Computer, bin(TimeGenerated, 10m)
| extend RiskKerb = case(
    DistinctSpnCount > HighRoastThreshold, 100,
    DistinctSpnCount > TgsThreshold,       70,
    0
)
| where RiskKerb >= 70
| extend Principal = TargetUserName
| project
    TimeGenerated = FirstSeen,
    DeviceName    = Computer,
    Principal,
    SourceTable   = "SecurityEvent",
    Signal        = "KerberoastStorm",
    Scenario      = strcat("Kerberoast SPN spray (", DistinctSpnCount, " distinct SPNs / 10m)"),
    RiskScore     = RiskKerb,
    Details       = strcat("SPNs: ", strcat_array(SpnList, "; "));

// -----------------------------------------------------------------------------
// Identity Signals (2): New host anomaly for account using Kerberos
// Simple baseline: past 7d (excluding last 24h) vs current 24h
// -----------------------------------------------------------------------------
let BaselineHosts =
SecurityEvent
| where TimeGenerated between (ago(baselineWindow) .. ago(lookback))
| where EventID in (4768, 4769)
| where TargetUserName !endswith "$"  // skip machine accounts
| summarize KnownComputers = make_set(Computer, 100) by TargetUserName;

let IdentityAnomalySignals =
SecurityEvent
| where TimeGenerated > ago(lookback)
| where EventID in (4768, 4769)
| where TargetUserName !endswith "$"
| project TimeGenerated, TargetUserName, Computer
| join kind=leftouter BaselineHosts on TargetUserName
| extend IsNewComputer = iif(isnull(KnownComputers) or not(Computer in~ KnownComputers), true, false)
| where IsNewComputer
| summarize
    FirstSeen = min(TimeGenerated),
    LastSeen  = max(TimeGenerated),
    EventCount = count()
  by TargetUserName, Computer
| where EventCount >= NewHostMinEvents
| extend
    IsPrivileged = TargetUserName in (PrivilegedAccounts)
                  or TargetUserName has_any (PrivilegedAccounts),
    RiskIdentity = case(
        IsPrivileged, 80,
        true,         60,
        0
    )
| extend Principal = TargetUserName
| project
    TimeGenerated = FirstSeen,
    DeviceName    = Computer,
    Principal,
    SourceTable   = "SecurityEvent",
    Signal        = "KerberosIdentityAnomaly",
    Scenario      = strcat("New Kerberos host for account (", EventCount, " events)"),
    RiskScore     = RiskIdentity,
    Details       = strcat("New host for user; baseline did not include ", Computer, ".");

// -----------------------------------------------------------------------------
// Cluster correlation: fold all signals into a single view + risk
// -----------------------------------------------------------------------------
union isfuzzy=true EndpointSignals, KerberoastSignals, IdentityAnomalySignals
| summarize
    FirstSeen      = min(TimeGenerated),
    LastSeen       = max(TimeGenerated),
    MaxRisk        = max(RiskScore),
    Signals        = make_set(Signal, 10),
    Scenarios      = make_set(Scenario, 10),
    SampleDetails  = any(Details),
    SourceHosts    = make_set(DeviceName, 10),
    SourceTables   = make_set(SourceTable, 10),
    Events         = count()
  by Principal, ClusterDevice = tostring(any(DeviceName))
| where MaxRisk >= 60
| extend
    HasEndpoint   = "EndpointTooling"           in (Signals),
    HasRoast      = "KerberoastStorm"           in (Signals),
    HasIdAnomaly  = "KerberosIdentityAnomaly"   in (Signals)
| extend Hunter_Directive = case(
    HasEndpoint and HasRoast and HasIdAnomaly,
        "CRITICAL: Kerberos attack cluster (tooling + Kerberoast + identity anomaly). Treat as domain compromise. Isolate hosts, review DCs, and investigate KRBTGT exposure.",
    HasEndpoint and HasRoast,
        "CRITICAL: Kerberos tooling and Kerberoast SPN spray in same cluster. Investigate lateral movement, dump and ticket abuse.",
    HasEndpoint and HasIdAnomaly,
        "CRITICAL: Kerberos tooling on a host where this account does not normally authenticate. Check for Golden ticket, PtH/PtT and unusual logons.",
    HasRoast and HasIdAnomaly,
        "HIGH: Kerberoast SPN spray from a new or unusual host for this account. Validate scanner usage, reset account password if not expected.",
    HasEndpoint,
        "HIGH: Kerberos offensive tooling detected. Confirm operator, isolate host if unapproved.",
    HasRoast,
        "HIGH: Kerberoast pattern (high SPN diversity). Confirm if this is a scanner; otherwise reset service account passwords.",
    HasIdAnomaly,
        "MEDIUM: New Kerberos host for this account. Check for local privilege escalation or ticket abuse.",
    "INFO: Kerberos signals below threshold; review if needed."
)
| project
    FirstSeen,
    LastSeen,
    Principal,
    ClusterDevice,
    MaxRisk,
    Signals,
    Scenarios,
    Events,
    SourceHosts,
    SourceTables,
    SampleDetails,
    Hunter_Directive
| order by MaxRisk desc, FirstSeen desc;

// ============================================================================
// 2) L3_Kerberos_Offensive_Tooling_Hunt_V3  (standalone endpoint hunt)
// ============================================================================

let lookback = 24h;
let SuspectTools = dynamic([
    "mimikatz.exe", "rubeus.exe", "kekeo.exe", "impacket.exe", "safetykatz.exe",
    "sharpkatz.exe", "bettersafetykatz.exe", "dumpert.exe"
]);
let PttRegex      = @"(?i)(/ptt\b|ticket::import|/ticket:[a-zA-Z0-9\-_]+\.(kirbi|ccache))";
let ForgingRegex  = @"(?i)(kerberos::golden|kerberos::silver|/sid:S-1-5|/id:500|/groups:512|/rc4:[a-f0-9]{32}|/aes256:[a-f0-9]{64})";
let DumpRegex     = @"(?i)(sekurlsa::tickets|sekurlsa::logonpasswords|/dump(?!bin)|/triage|/export|/monitor)";
let PthRegex      = @"(?i)(sekurlsa::pth|/pth\b|overpass-the-hash|overpass\b|/user:[^ ]+.*\/rc4:|/user:[^ ]+.*\/ntlm:|-hashes\s+:[a-fA-F0-9]{32,})";

DeviceProcessEvents
| where TimeGenerated > ago(lookback)
| where ProcessCommandLine has_any (
    "ticket","kerberos","sekurlsa","ptt","golden","silver",
    "rubeus","kekeo","kirbi","rc4","aes","overpass","sekurlsa::pth",
    "-hashes"
)
| extend
    IsSuspectTool   = FileName in~ (SuspectTools),
    IsForging       = ProcessCommandLine matches regex ForgingRegex,
    IsPtt           = ProcessCommandLine matches regex PttRegex,
    IsDump          = ProcessCommandLine matches regex DumpRegex,
    IsPth           = ProcessCommandLine matches regex PthRegex,
    HasKirbiFile    = ProcessCommandLine has ".kirbi",
    HasCCacheFile   = ProcessCommandLine has ".ccache"
| extend RiskScore =
       iif(IsForging, 100, 0)
     + iif(IsPth,     80,  0)
     + iif(IsPtt,     70,  0)
     + iif(IsDump,    60,  0)
     + iif(IsSuspectTool, 20, 0)
     + iif(HasKirbiFile or HasCCacheFile, 20, 0)
| where RiskScore >= 50
| extend Hunter_Directive = case(
    IsForging, strcat("CRITICAL: Golden/Silver ticket forging attempt via ", FileName, ". Isolate host and investigate KRBTGT exposure."),
    IsPth,     strcat("CRITICAL: Overpass-the-Hash / NTLM hash injection by ", FileName, ". Review lateral movement and clear tickets."),
    IsPtt,     strcat("HIGH: Pass-the-Ticket injection by ", FileName, ". Investigate source of stolen tickets."),
    IsDump,    strcat("HIGH: Ticket / credential dumping by ", FileName, ". Check LSASS access and downstream logons."),
    "MEDIUM: Kerberos-related tooling detected. Confirm if this is a known red team or admin activity."
)
| summarize
    Count      = count(),
    MaxRisk    = max(RiskScore),
    SampleCLI  = any(ProcessCommandLine)
  by DeviceName, FileName, AccountName, Hunter_Directive
| where not(Count > 15 and MaxRisk < 70)   // basic noise suppression for low-risk spam
| order by MaxRisk desc, Count desc;

// ============================================================================
// 3) L3_Kerberoasting_Storm_Hunt_V3  (standalone Kerberoast SPN spray hunt)
// ============================================================================

let lookback = 24h;
let TgsThreshold = 15;
let HighRoastThreshold = 30;
// Known scanner / vuln accounts that should be reviewed before alerting
let ScannerAccounts = dynamic(["svc_scan","svc_vuln","svc_monitor"]);

SecurityEvent
| where TimeGenerated > ago(lookback)
| where EventID == 4769
| where TicketEncryptionType == "0x17" or isempty(TicketEncryptionType)
| summarize
    DistinctSpnCount = dcount(ServiceName),
    SpnList          = make_set(ServiceName, 100),
    FirstSeen        = min(TimeGenerated),
    LastSeen         = max(TimeGenerated)
  by TargetUserName, Computer, bin(TimeGenerated, 10m)
| extend IsScanner = TargetUserName in~ (ScannerAccounts)
| extend RiskScore = case(
    DistinctSpnCount > HighRoastThreshold and not(IsScanner), 100,
    DistinctSpnCount > TgsThreshold       and not(IsScanner), 70,
    0
)
| where RiskScore >= 70
| extend Hunter_Directive = strcat(
    "CRITICAL: Possible Kerberoasting. Account '", TargetUserName,
    "' requested ", DistinctSpnCount, " distinct SPNs in 10 minutes from host '", Computer,
    "'. If this is not a known scanner, reset the account password and review for lateral movement."
)
| project
    FirstSeen,
    LastSeen,
    TargetUserName,
    Computer,
    DistinctSpnCount,
    RiskScore,
    Hunter_Directive,
    SpnList
| order by RiskScore desc, DistinctSpnCount desc;

// ============================================================================
// 4) L3_Kerberos_Identity_Anomaly_Hunt_V1  (simple new-host Kerberos anomaly)
// ============================================================================

let lookback = 24h;
let baselineWindow = 7d;
let NewHostMinEvents = 3;
let PrivilegedAccounts = dynamic([
    "Administrator","krbtgt","svc_backup","svc_sql","svc_ldap",
    "adm_", "_adm", ".admin"
]);

let BaselineHosts =
SecurityEvent
| where TimeGenerated between (ago(baselineWindow) .. ago(lookback))
| where EventID in (4768, 4769)
| where TargetUserName !endswith "$"
| summarize KnownComputers = make_set(Computer, 100) by TargetUserName;

SecurityEvent
| where TimeGenerated > ago(lookback)
| where EventID in (4768, 4769)
| where TargetUserName !endswith "$"
| project TimeGenerated, TargetUserName, Computer
| join kind=leftouter BaselineHosts on TargetUserName
| extend IsNewComputer = iif(isnull(KnownComputers) or not(Computer in~ KnownComputers), true, false)
| where IsNewComputer
| summarize
    FirstSeen  = min(TimeGenerated),
    LastSeen   = max(TimeGenerated),
    EventCount = count()
  by TargetUserName, Computer
| where EventCount >= NewHostMinEvents
| extend
    IsPrivileged = TargetUserName in (PrivilegedAccounts)
                   or TargetUserName has_any (PrivilegedAccounts),
    RiskScore = case(
        IsPrivileged, 80,
        true,         60,
        0
    )
| extend Hunter_Directive = case(
    IsPrivileged,
        strcat("HIGH: Privileged account '", TargetUserName,
               "' is using Kerberos from new host '", Computer,
               "'. Validate legitimacy and check for ticket abuse."),
    strcat("MEDIUM: Account '", TargetUserName,
           "' is using Kerberos from new host '", Computer,
           "'. Confirm legitimate change (new workstation, re-image, etc.).")
)
| project
    FirstSeen,
    LastSeen,
    TargetUserName,
    Computer,
    EventCount,
    RiskScore,
    Hunter_Directive
| order by RiskScore desc, EventCount desc;
