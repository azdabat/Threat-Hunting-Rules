Goal: catch both immediate ‚Äúdrop ‚Üí load‚Äù sideloading and stealthy ‚Äúdormant‚Äù activations (days ‚Üí weeks after implant), plus driver installs and registry edits that indicate DLL-based persistence.

Major building blocks

ImageLoads: module/DLL loads captured by MDE (DeviceImageLoadEvents).

FileCreates: file creation events for DLLs (DeviceFileEvents) to compute create‚Üíload latency (fast vs dormant).

SysDrops: .sys writes to drivers folder ‚Äî elevate risk for kernel persistence.

RegWrites: focused on registry keys/values that actually reference DLLs or control DLL-loading behavior (ServiceDll, InprocServer32, AppInit_DLLs, IFEO Debugger, LSA packages, Run keys, SafeDllSearchMode).

Prevalence table: counts how many devices have a SHA256 in 90d ‚Äî if rare, it worsens score.

Net/Proc context: process and network events near the load to provide situational evidence.

Scoring

BehaviorScore weighs fast loads and very long dormancy heavily (both can be malicious), unsigned files and rarity.

KillChainScore looks for driver drops, registry DLL mentions, calls to loader utilities, and user-writable paths (higher risk).

FinalScore is a weighted aggregate (tunable). Defaults: ALERT ‚â• 70, HUNT ‚â• 40.

Why fast vs dormant matter

Fast (‚â§5 min): classic drop-and-load ‚Äî high confidence when combined with unsigned/rare hash and unusual loader.

Dormant (days‚Üíweeks): supply-chain or staged operations trigger payload later; these require temporal scoring (we include DormantLong / VeryLong).

Why registry keys are now DLL-focused

Attackers use ServiceDll, InprocServer32, AppInit_DLLs, and IFEO to force DLLs to load in privileged contexts. We score these higher when the registry value itself mentions a DLL or loader command.

Driver (.sys) correlation

How to tune for your org

Adjust prevalenceWindow & thresholds to your environment size (larger org -> raise SeenDeviceCount threshold for 'rare').

Customize TrustedPublishers, CommonLoaders, and VendorProcesses to reduce FPs.

If you have Watchlists, replace dynamic lists with watchlist joins.

Consider raising fastLoadSec if your software update cycles legitimately create‚Üíload faster than 5 minutes.

Recommended analyst workflow when the rule returns ALERT

Isolate host (if allowed) and collect forensic artifacts (memory, full file, timeline).

Pull full process tree and parent/child relationships for loader.

Confirm signer / verify hash (upload to sandbox/VirusTotal if needed).

Pivot across estate for same SHA256 / filepath (hunt for lateral spread).

If confirmed malicious: create IOC & sighting in MISP, update detection playbooks.

Why This Is a High-Fidelity Hunt Rule
1. Behavioral + Temporal Correlation

It doesn‚Äôt rely on static hashes or threat intel ‚Äî it correlates:

File creation ‚Üí image load timing (fast or delayed).

Registry persistence modifications.

Driver drops (.sys) in near-time.

Network or process telemetry around the same window.

This means it‚Äôs detecting how attackers behave, not who they are ‚Äî a hallmark of L3-level fidelity.

‚û°Ô∏è Attackers rarely trigger all of these conditions together accidentally.
For example:
a signed vendor process loading an unsigned DLL 5 minutes after creation, which also modifies ServiceDll or AppInit_DLLs, is highly unlikely in normal enterprise workflows.

2. Weighted Confidence Scoring

The rule combines multiple signals:

FinalScore = (BehaviorScore √ó 0.6) + (KillChainScore √ó 0.3) + (RecencyScore √ó 0.1)


That weighting is deliberate:

BehaviorScore (0.6) ‚Üí fast/dormant load, unsigned, rare hash.

KillChainScore (0.3) ‚Üí driver/persistence/user-writable path indicators.

RecencyScore (0.1) ‚Üí fresh events get more attention.

‚Üí By aggregating independent behavioral indicators, the rule produces confidence-scored alerts (vs. noisy single-event matches).

That‚Äôs exactly what differentiates a high-fidelity hunt from a generic IOC match.

3. Rarity / Prevalence Suppression

It references OrgPrevalence:

coalesce(SeenDeviceCount,0) <= 2


So common DLLs (e.g. msvcrt.dll, ntdll.dll) loaded everywhere won‚Äôt trigger.
This drastically reduces false positives ‚Äî a huge factor in fidelity.

4. Contextual Enrichment Without External TI

Even without MISP or Sentinel, it builds its own context:
who wrote the DLL, where, how fast it loaded, which process loaded it, and what else happened near that time.

That context gives analysts immediate triage direction and maps directly to MITRE T1574.002, T1547., T1546., and T1543.* ‚Äî all known persistence and sideloading behaviors.

5. Resilient to Attacker Evasion

It‚Äôs effective against both:

Fast-loading payloads (drop ‚Üí load within 5 min).

Dormant implants (loaded days/weeks later).

That dual temporal detection catches both SolarWinds-style slow activations and 3CX-style fast DLL drops ‚Äî real-world tested evasion tactics.

‚ö†Ô∏è Where You Still Need Caution / Analyst Review

Even high-fidelity hunts produce some noise. Key sources:

Software updates that legitimately drop and reload DLLs fast (esp. installers / patch agents).
‚Üí Solution: whitelist installer signatures in TrustedPublishers.

Legit signed third-party DLLs in Run or ServiceDll keys.
‚Üí Use watchlists of known maintenance tools.

Drivers in test environments (dev/test signed .sys files).
‚Üí Use path-based exclusions for lab subnets or test hosts.

These are environment-dependent rather than design flaws.

üß† Analyst Talking Point (Interview / Documentation)

If asked:

‚ÄúWould this rule generate many false positives?‚Äù

You can confidently say:

‚ÄúIt‚Äôs engineered as a high-fidelity, low-volume hunt.
It relies on multi-signal scoring ‚Äî timing, signature status, rarity, and persistence behavior ‚Äî rather than a single indicator.
In a tuned production environment, we‚Äôd expect only a handful of daily hits, all worth triaging.‚Äù

Then add:

‚ÄúIt‚Äôs intentionally structured to surface only compound anomalies ‚Äî meaning at least 3‚Äì4 independent signals align.
That‚Äôs what moves it from correlation noise to analytical fidelity.‚Äù

‚úÖ Final Fidelity Rating (practical scale)
Fidelity Level	Description	This Rule
L1	IOC-only / noisy	‚ùå
L2	Single behavior correlation	‚ö†Ô∏è Partial
L3	Multi-signal, weighted, behavioral correlation	‚úÖ Yes
L4	ML/telemetry-adaptive (automated scoring)	Future integration with MISP/OpenCTI

A .sys file created near the load or a change to ServiceDll significantly increases severity (kernel persistence risk).
