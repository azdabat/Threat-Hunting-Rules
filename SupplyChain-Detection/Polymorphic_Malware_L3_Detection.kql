// =====================================================================================================
// HUNT 1 (L3): L3_Advanced_Polymorphic_Loader_Hunt
// Audience : L3 / Senior Threat Hunters
// WORK IN PROGRESS: UNTESTED RULE - See L2 Rule in Core Hunts for better fedelity
// Goal     : Surface NOVEL/TARGETED polymorphic loaders (DLL/SYS/EXE staging), fileless registry exec,
//            LOLBin chaining, fast load/delete, and fast C2 — with tenant-local prevalence enrichment.
// Noise    : Medium (by design). Use allowlists + prevalence enrichment to triage.
// =====================================================================================================

let lookback = 7d;
let dormant_window = 3d;

// --- TUNABLE: Writable / suspicious locations (edit per tenant)
let SuspiciousFolders = dynamic([
  @"C:\Users\",
  @"C:\ProgramData\",
  @"C:\Temp\",
  @"C:\Windows\Temp\",
  @"C:\Windows\Tasks\"
]);

// --- TUNABLE: LOLBins commonly abused
let LOLBins = dynamic([
  "rundll32.exe","regsvr32.exe","mshta.exe","powershell.exe",
  "pwsh.exe","wscript.exe","cscript.exe","cmd.exe",
  "bitsadmin.exe","certutil.exe","wmic.exe","msiexec.exe","installutil.exe"
]);

// --- TUNABLE: Known-good droppers / enterprise tooling to reduce hunt noise (keep small + specific)
let KnownGoodProcessNames = dynamic([
  // Examples (commented):
  // "sccmexec.exe","ccmsetup.exe","intuneManagementExtension.exe",
  // "chocolatey.exe","winget.exe","msbuild.exe"
]);

// --- TUNABLE: Known-good signer substrings (only use if you trust signing in your environment)
let KnownGoodSignerContains = dynamic([
  // Examples:
  // "Microsoft","Google","Cisco","Zoom","Slack Technologies","VMware"
]);

// --- Fileless registry execution indicators (detect/flag; do NOT decode)
let FilelessRegKeywords = dynamic([
  "powershell -enc","encodedcommand","frombase64string","[convert]::frombase64string",
  "iex ","invoke-expression","downloadstring","downloaddata",
  "rundll32","mshta","javascript:","vbscript:",
  "regsvr32","scrobj.dll"
]);

// --- Commandline high-entropy/base64-like blob detector
let Base64LikeRegex = @"[A-Za-z0-9\+/]{80,}={0,2}";

// -----------------------------------------------------------------------------------------------
// 0) Tenant-local prevalence enrichment (no FileProfile assumed)
// -----------------------------------------------------------------------------------------------
let TenantPrevalence =
DeviceFileEvents
| where Timestamp >= ago(lookback)
| where isnotempty(SHA256)
| summarize TenantDeviceCount = dcount(DeviceId), TenantEventCount = count() by SHA256;

// -----------------------------------------------------------------------------------------------
// 1) File staging surface (DLL/SYS/EXE dropped/modified/renamed) in suspicious folders
// -----------------------------------------------------------------------------------------------
let FileStage =
DeviceFileEvents
| where Timestamp >= ago(lookback)
| where ActionType in ("FileCreated","FileModified","FileRenamed")
| extend FileExt = tolower(split(FileName,".")[-1])
| where FileExt in ("dll","sys","exe")
| where FolderPath has_any (SuspiciousFolders)
| where InitiatingProcessFileName !in~ (KnownGoodProcessNames)
| project
    DeviceId,
    DeviceName,
    DropTime = Timestamp,
    DroppedFileName = FileName,
    DroppedFolderPath = FolderPath,
    DroppedFileExt = FileExt,
    DroppedSHA256 = SHA256,
    DroppingProcessName = InitiatingProcessFileName,
    DroppingProcessCommandLine = InitiatingProcessCommandLine,
    DroppingProcessId = InitiatingProcessId;

// -----------------------------------------------------------------------------------------------
// 2) Unsigned / suspicious image load surface (DLL/SYS)
// -----------------------------------------------------------------------------------------------
let UnsignedLoads =
DeviceImageLoadEvents
| where Timestamp >= ago(lookback)
| extend LoadedFileExt = tolower(split(FileName,".")[-1])
| where LoadedFileExt in ("dll","sys")
| extend UnsignedOrSuspicious = SignatureStatus in ("Unsigned","Invalid","Unknown") or isempty(Signer)
| where UnsignedOrSuspicious
| where InitiatingProcessFileName !in~ (KnownGoodProcessNames)
| project
    DeviceId,
    DeviceName,
    LoadTime = Timestamp,
    LoadedFileName = FileName,
    LoadedFolderPath = FolderPath,
    LoadedFileExt,
    LoadedSHA256 = SHA256,
    LoaderProcessName = InitiatingProcessFileName,
    LoaderProcessCommandLine = InitiatingProcessCommandLine,
    LoaderProcessId = InitiatingProcessId,
    Signer,
    SignatureStatus;

// -----------------------------------------------------------------------------------------------
// 3) File delete surface (drop → delete / cleanup)
// -----------------------------------------------------------------------------------------------
let FileDeletes =
DeviceFileEvents
| where Timestamp >= ago(lookback)
| where ActionType == "FileDeleted"
| project
    DeviceId,
    DeviceName,
    DeleteTime = Timestamp,
    DeletedFileName = FileName,
    DeletedFolderPath = FolderPath,
    DeletedSHA256 = SHA256,
    DeletingProcessName = InitiatingProcessFileName;

// -----------------------------------------------------------------------------------------------
// 4) Process execution surface (LOLBins + obfuscation + sandbox checks) — helps triage & correlation
// -----------------------------------------------------------------------------------------------
let ProcSurface =
DeviceProcessEvents
| where Timestamp >= ago(lookback)
| where ActionType == "ProcessCreated"
| where FileName !in~ (KnownGoodProcessNames)
| extend IsLOLBIN = iif(FileName in~ (LOLBins), 1, 0)
| extend HasBase64Blob = iif(ProcessCommandLine matches regex Base64LikeRegex, 1, 0)
| extend HasEncodedHints = iif(tolower(ProcessCommandLine) has_any (" -enc","encodedcommand","frombase64string","iex ","invoke-expression"), 1, 0)
| extend SandboxHints = iif(tolower(ProcessCommandLine) has_any ("vbox","vmware","qemu","sandboxie","wireshark","procmon","ollydbg","x64dbg","idag"), 1, 0)
| project
    DeviceId,
    DeviceName,
    ProcTime = Timestamp,
    ProcessId,
    ProcName = FileName,
    ProcCommandLine = ProcessCommandLine,
    ParentName = InitiatingProcessFileName,
    ParentCommandLine = InitiatingProcessCommandLine,
    ParentProcessId = InitiatingProcessId,
    IsLOLBIN,
    HasBase64Blob,
    HasEncodedHints,
    SandboxHints;

// -----------------------------------------------------------------------------------------------
// 5) Network surface (fast C2 / suspicious port). Keep broad; triage with timing + process name.
// -----------------------------------------------------------------------------------------------
let NetSurface =
DeviceNetworkEvents
| where Timestamp >= ago(lookback)
| where ActionType == "ConnectionSuccess"
| project
    DeviceId,
    DeviceName,
    NetTime = Timestamp,
    ProcessId,
    RemoteUrl,
    RemoteIP,
    RemotePort,
    NetProcName = InitiatingProcessFileName,
    NetProcCmd = InitiatingProcessCommandLine;

// -----------------------------------------------------------------------------------------------
// 6) Registry surface (fileless/persistence) — refined to detect EXEC-style registry data
// -----------------------------------------------------------------------------------------------
let FilelessRegistry =
DeviceRegistryEvents
| where Timestamp >= ago(lookback)
| where ActionType in ("RegistryValueSet","RegistryValueAdded")
| where RegistryValueData has_any (FilelessRegKeywords) or RegistryValueData matches regex Base64LikeRegex
| project
    DeviceId,
    DeviceName,
    RegTime = Timestamp,
    RegistryKey,
    RegistryValueName,
    RegistryValueData,
    RegProcessName = InitiatingProcessFileName,
    RegProcessCmd  = InitiatingProcessCommandLine;

// -----------------------------------------------------------------------------------------------
// 7) Correlate into a behavioural chain (flexible correlation; avoid PID-fragility)
//    - Prefer hash match when available
//    - Allow name match when hash missing (some telemetry gaps)
// -----------------------------------------------------------------------------------------------
FileStage
| join kind=leftouter (UnsignedLoads) on DeviceId, DeviceName
| where
    (isnotempty(DroppedSHA256) and DroppedSHA256 == LoadedSHA256)
    or (isempty(DroppedSHA256) and DroppedFileName == LoadedFileName)
| join kind=leftouter (FileDeletes) on DeviceId, DeviceName
| where
    (isnotempty(DroppedSHA256) and DroppedSHA256 == DeletedSHA256)
    or (isempty(DroppedSHA256) and DroppedFileName == DeletedFileName)
| join kind=leftouter (ProcSurface) on DeviceId
| join kind=leftouter (NetSurface) on DeviceId, $left.DroppingProcessId == $right.ProcessId
| join kind=leftouter (FilelessRegistry) on DeviceId, DeviceName
| join kind=leftouter (TenantPrevalence) on $left.DroppedSHA256 == $right.SHA256
| extend
    TenantDeviceCount = coalesce(TenantDeviceCount, 0),
    TenantEventCount  = coalesce(TenantEventCount, 0),
    LoadDelayMinutes  = iff(isnotempty(LoadTime), toint((LoadTime - DropTime)/1m), int(null)),
    DeleteDelayMinutes= iff(isnotempty(DeleteTime), toint((DeleteTime - DropTime)/1m), int(null)),
    FastDropToLoad    = iif(isnotempty(LoadTime) and LoadDelayMinutes between (0..5), 1, 0),
    DisappearingPayload = iif(isnotempty(LoadTime) and isnotempty(DeleteTime) and DeleteDelayMinutes between (0..30), 1, 0),
    DormantDLL        = iif(DroppedFileExt=="dll" and isnull(LoadTime) and DropTime <= now()-dormant_window, 1, 0),
    DormantDriver     = iif(DroppedFileExt=="sys" and isnull(LoadTime) and DropTime <= now()-dormant_window, 1, 0),
    FastC2            = iif(isnotempty(NetTime) and (NetTime - DropTime) between (0s..60s), 1, 0),
    SuspiciousPort    = iif(RemotePort !in (80,443,53,3389,25,587,993,995) and RemotePort != 0, 1, 0),
    DropperIsLOLBIN   = iif(DroppingProcessName in~ (LOLBins), 1, 0),
    LoaderIsLOLBIN    = iif(LoaderProcessName in~ (LOLBins), 1, 0),
    FilelessExec      = iif(isnotempty(RegistryKey), 1, 0),
    EncodedExecHints  = iif(HasEncodedHints==1 or HasBase64Blob==1, 1, 0)
| where
    // Hunt filter: show meaningful leads (NOT an alert threshold)
    FastDropToLoad==1 or DisappearingPayload==1 or FastC2==1 or FilelessExec==1 or DormantDriver==1 or DormantDLL==1
| extend
    // Hunt-friendly triage label (not “severity”)
    Triage =
      case(
        FilelessExec==1 and (EncodedExecHints==1 or RegistryValueData has_any ("javascript:","vbscript:","frombase64string","powershell -enc","scrobj.dll")), "HOT (FilelessExec)",
        DisappearingPayload==1 and FastC2==1, "HOT (Drop→Load→Delete + FastC2)",
        FastDropToLoad==1 and (LoaderIsLOLBIN==1 or DropperIsLOLBIN==1), "HIGH (FastLoad + LOLBin)",
        DormantDriver==1, "HIGH (Dormant SYS Staging)",
        DormantDLL==1, "MED (Dormant DLL Staging)",
        FastC2==1 or SuspiciousPort==1, "MED (C2 Lead)",
        "LEAD"
      )
| extend
    // Prevalence guidance (do NOT filter in hunt mode)
    PrevalenceHint =
      case(
        TenantDeviceCount <= 2, "RARE (<=2 devices) — strong polymorphic/tgt signal",
        TenantDeviceCount between (3..10), "LOW (3–10 devices) — possible campaign spread",
        TenantDeviceCount >= 50, "COMMON (>=50 devices) — likely updater/vendor; verify",
        "UNKNOWN (no hash)"
      )
| project
    LastSeen = coalesce(NetTime, DeleteTime, LoadTime, RegTime, DropTime),
    DeviceName,
    Triage,
    PrevalenceHint,
    TenantDeviceCount,
    TenantEventCount,
    DropTime,
    LoadTime,
    DeleteTime,
    NetTime,
    RegTime,
    DroppedFileName,
    DroppedFolderPath,
    DroppedFileExt,
    DroppedSHA256,
    DroppingProcessName,
    DroppingProcessCommandLine,
    LoadedFileName,
    LoadedFolderPath,
    LoadedSHA256,
    LoaderProcessName,
    LoaderProcessCommandLine,
    Signer,
    SignatureStatus,
    RemoteUrl,
    RemoteIP,
    RemotePort,
    RegistryKey,
    RegistryValueName,
    RegistryValueData,
    FastDropToLoad,
    DisappearingPayload,
    DormantDLL,
    DormantDriver,
    FastC2,
    SuspiciousPort,
    DropperIsLOLBIN,
    LoaderIsLOLBIN,
    EncodedExecHints,
    FilelessExec
| order by
    case(Triage startswith "HOT", 4, Triage startswith "HIGH", 3, Triage startswith "MED", 2, 1) desc,
    LastSeen desc
;

// ---------------------------------------------
// IR FRAMEWORK (L3) — Comprehensive (Commented)
// ---------------------------------------------
//
// 0) TRIAGE PRINCIPLES (Behaviour-First)
//    - Ignore “hash changed” anxiety; polymorphism is expected.
//    - Anchor on invariants: (Writable staging) + (Fast load/delete) + (Fileless exec) + (Fast C2).
//    - Use PrevalenceHint to cut noise without blinding yourself.
//
// 1) IDENTIFY / VALIDATE (Smoking Gun)
//    - Validate process lineage:
//        Malicious-leaning: user-facing app → script/LOLBin → drop → load → delete → outbound
//        Benign-leaning   : msiexec/setup → signed installer chain → expected domains
//    - Validate file properties:
//        DroppedFolderPath in suspicious locations? DroppedFileExt dll/sys/exe?
//        SignatureStatus unsigned/unknown? Signer empty?
//    - Validate registry (if FilelessExec=1):
//        RegistryValueData contains powershell -enc / frombase64string / javascript: / vbscript: / scrobj.dll?
//        Presence of long Base64-like blobs (HasBase64Blob / regex) is high-risk.
//    - Validate network (if FastC2=1):
//        RemoteUrl/RemoteIP new/unfamiliar? SuspiciousPort? First-seen within seconds of drop?
//
// 2) CONTAIN (Stop the Beacon)
//    - If Triage == HOT (FilelessExec) OR HOT (Drop→Load→Delete + FastC2):
//        - Isolate device (MDE) if operationally permitted.
//        - Block RemoteIP/RemoteUrl (defender indicators / perimeter controls).
//        - Preserve volatile state: trigger MDE forensic collection / memory capture if possible BEFORE isolation.
//
// 3) INVESTIGATE (Pivot / Scope)
//    - Pivot A (Payload spread):
//        Search DroppedSHA256 across tenant (7–30d). If TenantDeviceCount rises, treat as campaign.
//        Use the DroppedSHA256 to search your entire tenant. If the same behavior is seen elsewhere with different hashes, you are facing a polymorphic campaign.
//    - Pivot B (Infrastructure):
//        Search RemoteIP/RemoteUrl across tenant; cluster by destination + time.
//    - Pivot C (Registry campaign):
//        Search RegistryKey / RegistryValueName across endpoints; attackers often reuse persistence locations.
//    - Pivot D (Process lineage):
//        Investigate all children of DroppingProcessId and LoaderProcessId; check for injection indicators.
//    - Pivot E (Credential access):
//        If sustained outbound + suspicious process tree, check for LSASS access / token theft / browser data access.
//
// 4) ERADICATE
//    - Remove persistence:
//        Delete malicious Run/RunOnce/WMI/Task/Service entries associated with RegistryKey/ValueData.
//    - Remove artifacts:
//        Quarantine file if present; remove staged DLL/SYS from writable path.
//    - Credential hygiene:
//        If C2 confirmed or dwell suspected: reset user creds, revoke tokens, rotate service secrets as needed.
//
// 5) RECOVER
//    - Reimage if memory-only RAT suspected or kernel driver was staged/loaded.
//    - Re-onboard device and verify clean baseline (no re-creation of registry keys / tasks).
//
// 6) LESSONS LEARNED / HARDENING
//    - Enforce ASR rules (block Office child process, block credential stealing, block process injection).
//    - WDAC / App Control for LOLBins where feasible.
//    - Constrain writable paths usage for dev/build; add minimal allowlists for known-good tools.
//    - Track “COMMON (>=50 devices)” items and create precise allowlists (path+signer+tooling context).
// =====================================================================
