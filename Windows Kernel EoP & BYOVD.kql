// ============================================================================
// L3 Hunt: BYOVD_Kernel_EoP_Impact_Correlation (MDE-native, schema-valid)
// Author: Ala Dabat (refactor)
// Purpose:
//   Detect BYOVD-style kernel attack chains by correlating:
//   DriverLoad -> near-time post-load impact (SYSTEM process, service/driver reg, dump, C2)
// Notes:
//   - Driver loads are in DeviceEvents ActionType=DriverLoad :contentReference[oaicite:3]{index=3}
//   - BYOVD commonly abuses *signed* vulnerable drivers :contentReference[oaicite:4]{index=4}
// ============================================================================

let Lookback = 24h;
let CorrelationWindow = 15m;
let PostWindow = 45m;

// Optional: Known vulnerable driver enrichment (LOLDrivers.io)
// Comment this whole block out if you don't want external data pulls.
let LOLDrivers =
externaldata(Category:string, KnownVulnerableSamples:dynamic, Verified:string)
[h@"https://www.loldrivers.io/api/drivers.json"]
with (
  format=multijson,
  ingestionMapping=@'[{"Column":"Category","Properties":{"Path":"$.Category"}},{"Column":"KnownVulnerableSamples","Properties":{"Path":"$.KnownVulnerableSamples"}},{"Column":"Verified","Properties":{"Path":"$.Verified"}}]'
)
| mv-expand KnownVulnerableSamples
| extend DriverSHA1 = tostring(KnownVulnerableSamples.SHA1), DriverSHA256 = tostring(KnownVulnerableSamples.SHA256)
| project Category, Verified, DriverSHA1, DriverSHA256;

let DriverLoads =
DeviceEvents
| where Timestamp >= ago(Lookback)
| where ActionType == "DriverLoad"
| extend DriverSHA1 = tostring(SHA1), DriverSHA256 = tostring(SHA256)
| extend DriverFile = coalesce(FileName, tostring(AdditionalFields.FileName))
| extend DriverPath = coalesce(FolderPath, tostring(AdditionalFields.FolderPath))
| extend DriverSigner = tostring(AdditionalFields.Signer)
| extend DriverSigStatus = tostring(AdditionalFields.SignatureStatus)
| project
    DriverLoadTime = Timestamp,
    DeviceId, DeviceName,
    DriverFile, DriverPath,
    DriverSHA1, DriverSHA256,
    DriverSigner, DriverSigStatus,
    InitiatingProcessFileName,
    InitiatingProcessCommandLine,
    AccountName;

// Enrich with LOLDrivers if available
let DriverLoadsEnriched =
DriverLoads
| join kind=leftouter (LOLDrivers) on $left.DriverSHA256 == $right.DriverSHA256
| join kind=leftouter (LOLDrivers) on $left.DriverSHA1 == $right.DriverSHA1
| extend IsKnownVulnDriver = iif(isnotempty(Category) or isnotempty(Verified), 1, 0)
| extend VulnCategory = Category, VulnVerified = Verified;

let SystemProcSpawns =
DeviceProcessEvents
| where Timestamp >= ago(Lookback)
| where ActionType == "ProcessCreated"
| where tolower(AccountName) has "system" or tolower(AccountName) has "nt authority\\system"
| project
    SysProcTime = Timestamp,
    DeviceId, DeviceName,
    SysProc = FileName,
    SysCmd = ProcessCommandLine,
    SysAccount = AccountName,
    ParentProc = InitiatingProcessFileName,
    ParentCmd = InitiatingProcessCommandLine,
    ParentAccount = InitiatingProcessAccountName,
    ParentIntegrity = InitiatingProcessIntegrityLevel,
    ParentToken = InitiatingProcessTokenElevation,
    SysPID = ProcessId,
    ParentPID = InitiatingProcessId;

let ServiceOrDriverReg =
DeviceRegistryEvents
| where Timestamp >= ago(Lookback)
| where ActionType in ("RegistryValueSet","RegistryValueAdded")
| where RegistryKey has @"HKLM\SYSTEM\CurrentControlSet\Services\"
| extend DataLower = tolower(tostring(RegistryValueData))
| where DataLower has ".sys" or RegistryValueName in~ ("ImagePath","Type","Start","ErrorControl")
| project
    RegTime = Timestamp,
    DeviceId, DeviceName,
    RegistryKey, RegistryValueName, RegistryValueData,
    RegProc = InitiatingProcessFileName, RegCmd = InitiatingProcessCommandLine;

let CredDumpOrLSASS =
DeviceProcessEvents
| where Timestamp >= ago(Lookback)
| where ActionType == "ProcessCreated"
| where
    // common post-EoP / post-tamper dump tooling patterns (behavioural, not tool-name-only)
    ProcessCommandLine has_any ("comsvcs.dll","MiniDump","lsass","procdump","rundll32 comsvcs","sekurlsa","nanodump")
    or (FileName in~ ("rundll32.exe","procdump.exe","werfault.exe","taskmgr.exe") and ProcessCommandLine has "lsass")
| project
    DumpTime = Timestamp,
    DeviceId, DeviceName,
    DumpProc = FileName,
    DumpCmd = ProcessCommandLine,
    DumpParent = InitiatingProcessFileName,
    DumpParentCmd = InitiatingProcessCommandLine;

let NearTimeNet =
DeviceNetworkEvents
| where Timestamp >= ago(Lookback)
| where ActionType == "ConnectionSuccess"
| project
    NetTime = Timestamp,
    DeviceId, DeviceName,
    NetProc = InitiatingProcessFileName,
    NetCmd = InitiatingProcessCommandLine,
    RemoteIP, RemotePort, RemoteUrl;

// Correlate: DriverLoad -> (SYSTEM proc OR service/driver reg OR cred dump OR net) in tight windows
DriverLoadsEnriched
| join kind=leftouter (SystemProcSpawns) on DeviceId
| where isnull(SysProcTime) or SysProcTime between (DriverLoadTime .. DriverLoadTime + PostWindow)
| join kind=leftouter (ServiceOrDriverReg) on DeviceId
| where isnull(RegTime) or RegTime between (DriverLoadTime .. DriverLoadTime + PostWindow)
| join kind=leftouter (CredDumpOrLSASS) on DeviceId
| where isnull(DumpTime) or DumpTime between (DriverLoadTime .. DriverLoadTime + PostWindow)
| join kind=leftouter (NearTimeNet) on DeviceId
| where isnull(NetTime) or NetTime between (DriverLoadTime .. DriverLoadTime + PostWindow)
| extend
    // Scoring: prioritize known-vuln driver + impact signals
    Score =
        (20 * IsKnownVulnDriver)
      + (10 * iif(isnotempty(DriverSigner) and DriverSigStatus in ("Signed","Valid"), 1, 0)) // signed doesn't mean safe; just informational
      + (25 * iif(isnotempty(SysProc), 1, 0))
      + (20 * iif(isnotempty(RegistryKey), 1, 0))
      + (25 * iif(isnotempty(DumpProc), 1, 0))
      + (10 * iif(isnotempty(RemoteIP) or isnotempty(RemoteUrl), 1, 0))
      + (10 * iif(ParentIntegrity in ("Low","Medium") and ParentToken !in ("Full"), 1, 0)),
    Severity = case(
      Score >= 70, "CRITICAL",
      Score >= 50, "HIGH",
      Score >= 30, "MEDIUM",
      "LOW"
    )
| summarize
    FirstSeen = min(DriverLoadTime),
    LastSeen  = max(coalesce(SysProcTime, RegTime, DumpTime, NetTime, DriverLoadTime)),
    Drivers = make_set(strcat(DriverFile," | ",DriverPath," | ",coalesce(DriverSHA1,DriverSHA256)," | ",coalesce(DriverSigner,"")), 10),
    IsKnownVulnDriver = max(IsKnownVulnDriver),
    VulnCategory = any(VulnCategory),
    VulnVerified = any(VulnVerified),
    SystemProc = make_set(strcat(SysProc," :: ",SysCmd," :: Parent=",ParentProc," :: ParentIL=",ParentIntegrity," :: ParentToken=",ParentToken), 10),
    ServiceReg = make_set(strcat(RegistryKey,"\\",RegistryValueName,"=",RegistryValueData), 10),
    CredDump = make_set(strcat(DumpProc," :: ",DumpCmd," :: Parent=",DumpParent), 10),
    Net = make_set(strcat(coalesce(RemoteUrl,RemoteIP),":",tostring(RemotePort)," :: ",NetProc), 10),
    Score = max(Score),
    Severity = any(Severity)
  by DeviceId, DeviceName
| extend
    MITRE = "TA0004 Privilege Escalation; TA0005 Defense Evasion; TA0011 Command and Control",
    Techniques = "T1068 Exploitation for Privilege Escalation; T1547.006 Kernel Modules/Drivers; T1105 Ingress Tool Transfer; T1003 OS Credential Dumping (follow-on)",
    HunterDirective = case(
      Severity == "CRITICAL",
        "CRITICAL: DriverLoad correlated with post-load impact (SYSTEM execution and/or persistence/LSASS dump/C2). Treat as active kernel-level compromise. Isolate device, capture forensic package/memory if available, and pivot DriverSHA1/SHA256 + driver path across estate.",
      Severity == "HIGH",
        "HIGH: Strong BYOVD chain indicators. Validate driver against LOLDrivers / vendor legitimacy, confirm service/driver registry keys, and review SYSTEM process tree + outbound connections within 45m of load.",
      Severity == "MEDIUM",
        "MEDIUM: Suspicious driver load with partial impact signals. Validate against known IT tooling, hardware utilities, and deployment activity; hunt for recurrence on same driver hash/path.",
      "LOW: Driver load surfaced without strong impact signals. Use for enrichment and baseline; consider tightening with allowlists.")
| project
    FirstSeen, LastSeen,
    DeviceName,
    Severity, Score,
    IsKnownVulnDriver, VulnCategory, VulnVerified,
    Drivers, SystemProc, ServiceReg, CredDump, Net,
    MITRE, Techniques, HunterDirective
| order by Score desc, LastSeen desc
;
