// ==============================
//Ala Dabat: Original LOLdriver Detection rule
// SOC Threat Hunting
// Default: ONLY Category == "malicious"
//Append results to VT
// Wont catch modern BYOVD attacks in 2025 for Zero-days (see MISP section for rule update)
// ==============================

let VulnerableDriverData = externaldata (
    Id:string, Author:string, Created:string, Command:string, Description:string, Usecase:string, Category:string, Privileges:string, MitreID:string, OperatingSystem:string, Resources:string, DriverInfo:string, ContactPerson:string, HandleReference:string, DetectionMethod:string, MD5_Hashes:string, SHA1_Hashes:string, SHA256_Hashes:string, PublisherInfo:string, CompanyInfo:string, VulnerabilityDetails:string, MD5_Authentihash:string, SHA256_Authentihash:string, SHA1_Authentihash:string, VerificationStatus:string, TagsInfo:string
) ["https://www.loldrivers.io/api/drivers.csv"] with (format="csv", ignoreFirstRecord=true);

let VulnerableDriversSHA256 = VulnerableDriverData
| extend IndividualSHA256 = split(SHA256_Hashes, ', ')
| mv-expand IndividualSHA256
| where isnotempty(IndividualSHA256)
| extend NormalizedSHA256 = trim(" ", tolower(IndividualSHA256));

let LoadedDrivers = DeviceEvents
| where ActionType has "DriverLoad"
| extend NormalizedDeviceSHA256 = trim(" ", tolower(SHA256));

LoadedDrivers
| join kind=inner VulnerableDriversSHA256 on $left.NormalizedDeviceSHA256 == $right.NormalizedSHA256
| where not(FileName == "DBUtilDrv2.sys" and Category != "Vulnerable Driver")
| summarize arg_max(Timestamp, *) by DeviceName, NormalizedDeviceSHA256
| extend VT_Domain = iff(isnotempty(NormalizedDeviceSHA256), strcat("https://www.virustotal.com/gui/file/", NormalizedDeviceSHA256), NormalizedDeviceSHA256)
| project-away ContactPerson, HandleReference;





// ==============================
// Malicious Driver Hunt (SOC Threat Hunting)
// Source: LOLDrivers CSV schema (matches your attached file)
// Default: ONLY Category == "malicious"
// To also include vulnerable drivers, UNCOMMENT the block marked "OPTIONAL: include vulnerable"
// ==============================

let lookback = 30d;

// --- 1) Load the driver catalog (schema matches your uploaded CSV) ---
let DriverCatalogRaw = materialize(
    externaldata(
        Id:string,
        Author:string,
        Created:string,
        Command:string,
        Description:string,
        Usecase:string,
        Category:string,
        Privileges:string,
        MitreID:string,
        OperatingSystem:string,
        Resources:string,
        ['Driver Description']:string,
        Person:string,
        Handle:string,
        Detection:string,
        KnownVulnerableSamples_MD5:string,
        KnownVulnerableSamples_SHA1:string,
        KnownVulnerableSamples_SHA256:string,
        KnownVulnerableSamples_Authentihash_MD5:string,
        KnownVulnerableSamples_Authentihash_SHA1:string,
        KnownVulnerableSamples_Authentihash_SHA256:string,
        Verified:string,
        Tags:string
    )
    ["https://www.loldrivers.io/api/drivers.csv"]
    with (format="csv", ignoreFirstRecord=true)
    // keep only the columns we use downstream
    | project
        Id,
        Category,
        Privileges,
        DriverDescription = ['Driver Description'],
        Detection,
        Verified,
        Tags,
        MD5s  = KnownVulnerableSamples_MD5,
        SHA1s = KnownVulnerableSamples_SHA1,
        SHA256s = KnownVulnerableSamples_SHA256,
        AuthMD5  = KnownVulnerableSamples_Authentihash_MD5,     // reference only; not used for matching
        AuthSHA1 = KnownVulnerableSamples_Authentihash_SHA1,    // reference only; not used for matching
        AuthSHA256 = KnownVulnerableSamples_Authentihash_SHA256 // reference only; not used for matching
);

// --- 2) Select rows to hunt: default = malicious only ---
// OPTIONAL: include vulnerable records by UNCOMMENTING the indicated line
let CatalogForHunt =
    DriverCatalogRaw
    | extend Category_l = tolower(coalesce(Category, ""))
    | where Category_l == "malicious"
    // | where Category_l == "malicious" or Category_l startswith "vulnerable"   // <-- OPTIONAL: include vulnerable

;

// --- 3) Explode known sample hashes (SHA256/SHA1/MD5) into a unified hash feed ---
// Note: DeviceEvents exposes SHA256/SHA1/MD5 (no "authentihash"), so we match on these three.
let DriverHashFeed = materialize(
    union
        (CatalogForHunt
            | extend HashList = split(replace_string(coalesce(SHA256s,""), ";", ","), ",")
            | mv-expand HashList to typeof(string)
            | extend Hash = tolower(trim(@" \t\r\n""'", HashList))
            | where isnotempty(Hash)
            | project Id, Category, Privileges, DriverDescription, Detection, Verified, Tags, Hash, HashType="SHA256")
    ,
        (CatalogForHunt
            | extend HashList = split(replace_string(coalesce(SHA1s,""), ";", ","), ",")
            | mv-expand HashList to typeof(string)
            | extend Hash = tolower(trim(@" \t\r\n""'", HashList))
            | where isnotempty(Hash)
            | project Id, Category, Privileges, DriverDescription, Detection, Verified, Tags, Hash, HashType="SHA1")
    ,
        (CatalogForHunt
            | extend HashList = split(replace_string(coalesce(MD5s,""), ";", ","), ",")
            | mv-expand HashList to typeof(string)
            | extend Hash = tolower(trim(@" \t\r\n""'", HashList))
            | where isnotempty(Hash)
            | project Id, Category, Privileges, DriverDescription, Detection, Verified, Tags, Hash, HashType="MD5")
)
| summarize any(Id), any(Category), any(Privileges), any(DriverDescription), any(Detection), any(Verified), any(Tags) by Hash, HashType
| project
    Hash,
    HashType,
    Id                = any_Id,
    Category          = any_Category,
    Privileges        = any_Privileges,
    DriverDescription = any_DriverDescription,
    Detection         = any_Detection,
    Verified          = any_Verified,
    Tags              = any_Tags
;

// --- 4) Collect driver load telemetry from endpoints (last 30 days by default) ---
let DriverLoads =
    DeviceEvents
    | where Timestamp >= ago(lookback)
    | where ActionType has_any ("DriverLoad","LoadedKernelModule")
    | extend
        FileName   = tostring(FileName),
        FolderPath = tostring(FolderPath),
        SHA256_l   = tolower(tostring(SHA256)),
        SHA1_l     = tolower(tostring(SHA1)),
        MD5_l      = tolower(tostring(MD5))
    | project Timestamp, DeviceId, DeviceName, FileName, FolderPath,
              InitiatingProcessFileName, InitiatingProcessCommandLine,
              SHA256_l, SHA1_l, MD5_l
;

// --- 5) Match any observed driver loads to the malicious (or optional vulnerable) hash feed ---
DriverLoads
| extend HashCandidates = pack_array(SHA256_l, SHA1_l, MD5_l)
| mv-expand HashCandidates
| extend Hash = tolower(tostring(HashCandidates))
| where isnotempty(Hash)
| join kind=inner (DriverHashFeed) on Hash
// --- 6) Present results clearly for a hunter ---
| summarize
    FirstSeen   = min(Timestamp),
    LastSeen    = max(Timestamp),
    LoadCount   = count(),
    SampleProc  = arg_max(Timestamp, InitiatingProcessFileName),
    SampleCmd   = arg_max(Timestamp, InitiatingProcessCommandLine),
    SampleFile  = any(FileName),
    SamplePath  = any(FolderPath)
  by DeviceId, DeviceName, Hash, HashType, Id, Category, Privileges, DriverDescription, Detection, Verified, Tags
| extend
    HitClass = iif(tolower(Category) == "malicious", "MALICIOUS", "VULNERABLE"),  // will read MALICIOUS unless you enabled vulnerable
    VT_File  = strcat("https://www.virustotal.com/gui/file/", Hash),
    MITRE_Tactics    = "TA0005: Defense Evasion; TA0004: Privilege Escalation",
    MITRE_Techniques = "T1068; T1548; T1562",
    HuntingDirectives = pack_array(
        strcat("1) Confirm if driver '", SampleFile, "' (", HashType, "=", Hash, ") is expected on ", DeviceName, "."),
        strcat("2) Class: ", HitClass, " (Category=", Category, ") | Description: ", coalesce(DriverDescription,"n/a")),
        strcat("3) Loader: ", tostring(SampleProc), " | Cmd: ", tostring(SampleCmd)),
        "4) Enrich: check signature status & driver catalog entries; open VT link for this file hash.",
        strcat("5) VT: ", VT_File),
        "6) Pivot estate-wide by Hash and FileName in DeviceEvents and DeviceFileEvents.",
        "7) Hunt for post-load abuse: EDR service tampering, AMSI/ETW patching, LSASS access, or suspicious IOCTL activity.",
        "8) If MALICIOUS: isolate host, capture memory, remove/contain driver, and apply WDAC/HVCI controls.",
        "9) If VULNERABLE (enabled option): contact owner, update/replace driver, or add WDAC deny rule."
    )
| project
    FirstSeen, LastSeen, LoadCount,
    DeviceName, DeviceId,
    SampleFile, SamplePath,
    Hash, HashType,
    HitClass, Category, Privileges, DriverDescription, Detection, Verified, Tags,
    VT_File, MITRE_Tactics, MITRE_Techniques, HuntingDirectives
| order by case(HitClass == "MALICIOUS", 2, 1) desc, LastSeen desc
